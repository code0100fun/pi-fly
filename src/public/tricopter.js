// Generated by CoffeeScript 1.3.3
var Body, Boom, Model, Motor, Scene, Simulation, Tricopter, Vector,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Model = (function() {

  function Model() {}

  Model.prototype.outline = 0x000000;

  Model.prototype.fill = 0xff0000;

  Model.prototype.createMesh = function() {
    return THREE.SceneUtils.createMultiMaterialObject(this.createGeometry(), [this.createOutlineMaterial(this.outline), this.createFillMaterial(this.fill)]);
  };

  Model.prototype.createOutlineMaterial = function(color) {
    return new THREE.MeshBasicMaterial({
      color: color,
      shading: THREE.FlatShading,
      wireframe: true,
      transparent: true
    });
  };

  Model.prototype.createFillMaterial = function(color) {
    return new THREE.MeshBasicMaterial({
      color: color
    });
  };

  return Model;

})();

Tricopter = (function(_super) {

  __extends(Tricopter, _super);

  Tricopter.prototype.buildMotor = function(rotation) {
    var boom, group, motor, motorGrp, vector;
    motor = new Motor(80, 0, 0);
    boom = new Boom(47, 0, 0);
    vector = new Vector(80, 0, 0);
    motorGrp = new THREE.Object3D();
    group = new THREE.Object3D();
    motorGrp.add(motor.mesh);
    motorGrp.add(vector.mesh);
    group.add(motorGrp);
    group.add(boom.mesh);
    group.rotation.y = rotation;
    return {
      group: group,
      boom: boom,
      motor: motorGrp,
      vector: vector
    };
  };

  function Tricopter() {
    var body, bodyGrp, group;
    group = new THREE.Object3D();
    this.motor1 = this.buildMotor(Math.PI * (1 / 2));
    group.add(this.motor1.group);
    this.motor2 = this.buildMotor(Math.PI * (7 / 6));
    group.add(this.motor2.group);
    this.motor3 = this.buildMotor(Math.PI * (11 / 6));
    group.add(this.motor3.group);
    body = new Body(0, 0, 0);
    bodyGrp = new THREE.Object3D();
    bodyGrp.add(body.mesh);
    group.add(bodyGrp);
    this.mesh = group;
  }

  return Tricopter;

})(Model);

Motor = (function(_super) {

  __extends(Motor, _super);

  Motor.prototype.radius = 10;

  Motor.prototype.height = 10;

  Motor.prototype.fill = 0x222222;

  Motor.prototype.createGeometry = function() {
    return new THREE.CylinderGeometry(this.radius, this.radius, this.height, 16);
  };

  function Motor(x, y, z) {
    this.mesh = this.createMesh();
    this.mesh.position.x = x;
    this.mesh.position.y = y;
    this.mesh.position.z = z;
  }

  return Motor;

})(Model);

Boom = (function(_super) {

  __extends(Boom, _super);

  Boom.prototype.width = 4;

  Boom.prototype.length = 50;

  Boom.prototype.fill = 0x333333;

  Boom.prototype.createGeometry = function() {
    return new THREE.CubeGeometry(this.length, this.width, this.width);
  };

  function Boom(x, y, z) {
    this.mesh = this.createMesh();
    this.mesh.position.x = x;
    this.mesh.position.y = y;
    this.mesh.position.z = z;
  }

  return Boom;

})(Model);

Body = (function(_super) {

  __extends(Body, _super);

  Body.prototype.radius = 25;

  Body.prototype.height = 5;

  Body.prototype.fill = 0xCCCC33;

  Body.prototype.createGeometry = function() {
    return new THREE.CylinderGeometry(this.radius, this.radius, this.height, 12);
  };

  function Body(x, y, z) {
    this.mesh = this.createMesh();
    this.mesh.position.x = x;
    this.mesh.position.y = y;
    this.mesh.position.z = z;
  }

  return Body;

})(Model);

Vector = (function(_super) {

  __extends(Vector, _super);

  Vector.prototype.width = 10;

  Vector.prototype.length = 20;

  Vector.prototype.thickness = 3;

  Vector.prototype.fill = 0x0000FF;

  Vector.prototype.setLength = function(length) {
    var scale;
    if (length === 0) {
      return;
    }
    scale = length / this.length;
    this.length = length;
    this.bodyMesh.scale.y *= scale;
    this.bodyMesh.position.y = -(this.y + this.length / 2 + this.width / 2);
    return this.mesh.position.y = -(this.width + this.length);
  };

  Vector.prototype.createGeometry = function() {
    var head;
    head = new THREE.CylinderGeometry(this.width, this.width, this.thickness, 3);
    return head;
  };

  function Vector(x, y, z) {
    var group, mesh;
    group = new THREE.Object3D();
    this.body = new THREE.CubeGeometry(this.width * 0.7, this.length, this.thickness);
    this.bodyMesh = THREE.SceneUtils.createMultiMaterialObject(this.body, [this.createOutlineMaterial(this.outline), this.createFillMaterial(this.fill)]);
    this.y = y;
    this.bodyMesh.position.x = x;
    this.bodyMesh.position.y = -(y + this.length / 2 + this.width / 2);
    this.bodyMesh.position.z = z;
    mesh = this.createMesh();
    mesh.position.x = x;
    mesh.position.y = y;
    mesh.position.z = z;
    mesh.rotation.x = 3 * Math.PI / 2;
    group.add(mesh);
    group.add(this.bodyMesh);
    group.position.y = -(this.width + this.length);
    group.rotation.x = Math.PI;
    this.mesh = group;
  }

  return Vector;

})(Model);

Scene = (function() {

  function Scene() {}

  return Scene;

})();

Simulation = (function() {

  Simulation.prototype.viewAngle = 45;

  Simulation.prototype.near = 0.1;

  Simulation.prototype.far = 10000;

  function Simulation(options) {
    var _base, _base1, _base2, _ref, _ref1, _ref2, _ref3;
    this.options = options;
    this.animate = __bind(this.animate, this);

    this.start = __bind(this.start, this);

    this.init = __bind(this.init, this);

    if ((_ref = this.options) == null) {
      this.options = {};
    }
    if ((_ref1 = (_base = this.options).el) == null) {
      _base.el = $('body');
    }
    if ((_ref2 = (_base1 = this.options).width) == null) {
      _base1.width = 800;
    }
    if ((_ref3 = (_base2 = this.options).height) == null) {
      _base2.height = 600;
    }
  }

  Simulation.prototype.init = function() {
    var blockSize, boundingBox, config, geometry, material;
    this.aspect = this.options.width / this.options.height;
    this.renderer = new THREE.WebGLRenderer();
    this.camera = new THREE.PerspectiveCamera(this.viewAngle, this.aspect, this.near, this.far);
    this.scene = new THREE.Scene();
    this.camera.position.z = 500;
    this.scene.add(this.camera);
    this.renderer.setSize(this.options.width, this.options.height);
    this.options.el.append(this.renderer.domElement);
    config = {
      width: 360,
      height: 360,
      depth: 1080,
      splitX: 6,
      splitY: 6,
      splitZ: 18
    };
    blockSize = config.width / config.splitX;
    geometry = new THREE.CubeGeometry(config.width, config.height, config.depth, config.splitX, config.splitY, config.splitZ);
    material = new THREE.MeshBasicMaterial({
      color: 0xffaa00,
      wireframe: true
    });
    boundingBox = new THREE.Mesh(geometry, material);
    this.scene.add(boundingBox);
    this.tricopter = new Tricopter();
    this.scene.add(this.tricopter.mesh);
    this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
    this.renderer.render(this.scene, this.camera);
    return this.start();
  };

  Simulation.prototype.start = function() {
    return this.animate();
  };

  Simulation.prototype.animate = function() {
    this.controls.update();
    this.renderer.render(this.scene, this.camera);
    return window.requestAnimationFrame(this.animate);
  };

  return Simulation;

})();
